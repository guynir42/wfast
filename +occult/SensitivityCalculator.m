classdef SensitivityCalculator < handle

    properties(Transient=true)
        
    end
    
    properties % objects
        
        cat; % table with the cone search results
        bc@util.ast.BolometricCorrections;
        
    end
    
    properties % inputs/outputs
        
        % these need to be loaded from the "score.mat" file, or generated by makeScoreMatrix
        score; 
        r;
        R;
        b;
        v;
        delta;
        
        bol_mag;
        bol_temp;
        
    end
    
    properties % switches/controls
        
        lambda = 550; % nanometer
        stars = 5000;
        years = 3;
        days = 300;
        hours = 6;
        
        debug_bit = 1;
        
    end
    
    properties(Dependent=true)
        
        
        
    end
    
    properties(Hidden=true)
       
        version = 1.00;
        
    end
    
    methods % constructor
        
        function obj = SensitivityCalculator(varargin)
            
            if ~isempty(varargin) && isa(varargin{1}, 'occult.SensitivityCalculator')
                if obj.debug_bit, fprintf('SensitivityCalculator copy-constructor v%4.2f\n', obj.version); end
                obj = util.oop.full_copy(varargin{1});
            else
                if obj.debug_bit, fprintf('SensitivityCalculator constructor v%4.2f\n', obj.version); end
            
            end
            
        end
        
    end
    
    methods % reset/clear
        
    end
    
    methods % getters
        
        function val = FSU_km(obj, distance_au)
            
            if nargin<2 || isempty(distance_au)
                distance_au = 40;
            end
            
            val = sqrt(obj.lambda.*1e-12.*(distance_au.*150e6)/2);
            
        end
        
        function val = FSU_deg(obj, distance_au)
            
            
            if nargin<2 || isempty(distance_au)
                distance_au = 40;
            end
            
            val = sqrt(obj.lambda.*1e-12./(distance_au.*150e6)/2).*180./pi;
            
        end
        
    end
    
    methods % setters
        
    end
    
    methods % score matrix stuff
        
        function makeScoreMatrix(obj, varargin)
            
        end
        
        function saveScoreMatrix(obj, filename)
            
        end
        
        function loadScoreMatrix(obj, filename)
            
            if nargin<2 || isempty(filename)
                filename = 'score.mat';
            end
            
            [dirname, file, ext] = fileparts(filename);
            
            if isempty(dirname)
                dirname = fullfile(getenv('WFAST'), '+occult');
            end
            
            load_struct = load(fullfile(dirname, [file ext]));
            
            obj.score = load_struct.score;
            obj.r = load_struct.r;
            obj.R = load_struct.R;
            obj.b = load_struct.b;
            obj.v = load_struct.v;
            obj.delta = load_struct.delta;
            
        end
        
    end
    
    methods % calculations
        
        function coneSearch(obj, varargin)
            
            if isempty(obj.bc)
                obj.bc = util.ast.BolometricCorrections;
            end
            
            obj.cat = util.ast.coneSearch(varargin{:}, 'bolometric', obj.bc);
            
            obj.cat(isnan(obj.cat{:, 'bol_mag'}),:) = []; % get rid of stars with NaN values 
            
            obj.bol_mag = obj.cat.bol_mag;
            obj.bol_temp = obj.cat.bol_temp;
            
        end
        
        function coverage = calculateCoverage(obj, distance_au, threshold)
            
            if nargin<3 || isempty(threshold)
                threshold = 5;
            end
            
            if isempty(obj.bol_mag) || isempty(obj.bol_temp)
                error('Cannot calculate rate without a stellar radius distribution, given as "bol_mag" and "bol_temp". Try running "coneSearch"...');
            end
            
            sizes = occult.stellar_size(obj.bol_mag, obj.bol_temp, distance_au);
            
            % get the size distribution and renormalize it to the given total star number
            size_counts = histcounts(sizes, 'BinEdges', [obj.R-obj.delta/2 obj.R(end)+obj.delta/2]); 
            size_counts = size_counts./sum(size_counts);
            size_counts = size_counts.*obj.stars;
            
            FSU = sqrt(obj.lambda.*1e-12.*distance_au.*150e6./2); % convert FSU to km
            fsu = sqrt(obj.lambda.*1e-12./2./(distance_au.*150e6)).*180./pi; % convert FSU to degrees
            
            % find the indices in obj.v that correspond to 3<v<30 km/sec
            v_idx1 = find(obj.v.*FSU>=3, 1, 'first');
            v_idx2 = find(obj.v.*FSU<=30, 1, 'last');
            
            Nv = v_idx2-v_idx1+1; % number of velocity bins we are using
            
            coverage = zeros(length(obj.r),1); 
            
            for ii = 1:length(obj.r)
                
                for jj = 1:length(obj.R)
                    
                    if size_counts(jj)>0
                        
                        for kk = 1:length(obj.b)
                        
                            for mm = v_idx1:v_idx2 % only take velocities in the correct range
                            
                                if obj.score(ii,jj,kk,mm)>threshold
                                    coverage(ii) = coverage(ii) + size_counts(jj).*2.*obj.v(mm).*obj.delta./Nv;
                                end
                            
                            end % for v(mm)
                            
                        end % for b(kk)
                        
                    end % if N(R)>0
                    
                end % for R(jj)
                
            end % for r(ii)
           
            coverage = coverage.*fsu.^2./41253.*obj.years.*obj.days.*obj.hours.*3600; % fraction of the sky covered for the whole duration of the experiment
            
        end
        
    end
    
    methods % plotting tools / GUI
        
        function h_out = hist_sizes(obj, distance_au, varargin)
            
            input = util.text.InputVars;
            input.input_var('ax', [], 'axes', 'axis');
            input.scan_vars(varargin{:});
            
            if isempty(input.ax)
                input.ax = gca;
            end
            
            sizes = occult.stellar_size(obj.bol_mag, obj.bol_temp, distance_au);
            h = histogram(input.ax, sizes, 'BinEdges', obj.R-obj.delta/2); 
            
            xlabel(input.ax, sprintf('Stellar size [FSU] for D= %d AU', distance_au));
            
            if nargout>0
                h_out = h;
            end
            
        end
        
        function [h_line, h_area] = plot_expected(obj, varargin)
            
            input = util.text.InputVars;
            input.input_var('N', 1e12, 'Ntot', 'number objects');
            input.input_var('r0', 1, 'r_min', 'minimal_radius', 'min radius'); 
            input.input_var('q', 3); 
            input.input_var('line_width', 3); 
            input.input_var('line_style', '-'); 
            input.input_var('color', 'black'); 
            input.input_var('ax', [], 'axes', 'axis');
            input.input_var('add', [], 'hold');
            input.input_var('log', 1, 'log scale');
            input.scan_vars(varargin{:});
            
            if isempty(input.ax)
                input.ax = gca;
            end
            
            holding_pattern = input.ax.NextPlot;
            
            if ~isempty(input.add) && util.text.parse_bool(input.add)
                input.ax.NextPlot = 'add';
            elseif ~isempty(input.add) && ~util.text.parse_bool(input.add)
                input.ax.NextPlot = 'replace';
            end
            
            func = @(r) (r./input.r0).^(1-input.q);
            
            if isscalar(input.N)
                Nmean = input.N;
                Nupper = Nmean*10 - Nmean;
                Nlower = Nmean - Nmean/10;
            elseif length(input.N)==3            
                Nmean = input.N(2);
                Nupper = input.N(3)-input.N(2);
                Nlower = input.N(2)-input.N(1);
            end
            
            r_km = input.r0:0.1:50;
            
            [h1,h2] = util.plot.shaded(r_km, Nmean.*func(r_km), [Nlower; Nupper].*func(r_km), 'ax', input.ax);
            h1.LineWidth = input.line_width;
            h1.Color = input.color;
            h1.DisplayName = 'Expected number';
            h2.DisplayName = 'Uncertainty';

            if ~isempty(input.log) && util.text.parse_bool(input.log)
                input.ax.YScale = 'log';
            elseif ~isempty(input.log) && ~util.text.parse_bool(input.log)
                input.ax.YScale = 'linear';
            end
            
            xlabel(input.ax, 'Occulter radius [km]');
            ylabel(input.ax, 'Cumulative number');

            input.ax.NextPlot = holding_pattern;

            input.ax.XLim = [1 10];
            
            if nargout>0
                h_line = h1;
            end
            
            if nargout>1
                h_area = h2;
            end
            
            
        end
        
        function h_out = plot_sensitivity(obj, varargin)
            
            input = util.text.InputVars;
            input.use_ordered_numeric = 1;
            input.input_var('distance', 3000, 'distance_au'); % in AU
            input.input_var('threshold', 7.5); % detection threshold
            input.input_var('ax', [], 'axes', 'axis');
            input.input_var('line_width', 3); 
            input.input_var('line_style', '-'); 
            input.input_var('marker_style', 'none');
            input.input_var('marker_size', 15); 
            input.input_var('color', 'black'); 
            input.input_var('string', '', 'name', 'display name');
            input.input_var('add', [], 'hold');
            input.input_var('log', [], 'log scale');
            input.scan_vars(varargin{:});
            
            if isempty(input.ax)
                input.ax = gca;
            end
            
            holding_pattern = input.ax.NextPlot;
            
            if ~isempty(input.add) && util.text.parse_bool(input.add)
                input.ax.NextPlot = 'add';
            elseif ~isempty(input.add) && ~util.text.parse_bool(input.add)
                input.ax.NextPlot = 'replace';
            end
            
            FSU = sqrt(obj.lambda.*1e-12.*input.distance.*150e6./2); % convert FSU to km
%             fsu = sqrt(obj.lambda.*1e-12./2./(input.distance.*150e6)).*180./pi; % convert FSU to degrees
            
            coverage = obj.calculateCoverage(input.distance, input.threshold);
            
            h = plot(input.ax, obj.r.*FSU, 1./coverage); 
            h.LineWidth = input.line_width;
            h.LineStyle = input.line_style;
            h.Marker = input.marker_style;
            h.MarkerSize = input.marker_size;
            h.Color = input.color;
            h.DisplayName = input.string;
            
            if ~isempty(input.log) && util.text.parse_bool(input.log)
                input.ax.YScale = 'log';
            elseif ~isempty(input.log) && ~util.text.parse_bool(input.log)
                input.ax.YScale = 'linear';
            end
            
            xlabel(input.ax, 'Occulter radius [km]');
            ylabel(input.ax, 'Cumulative number');
                        
            input.ax.NextPlot = holding_pattern;

            if nargout>0
                h_out = h;
            end
            
            
        end
        
    end    
    
end














